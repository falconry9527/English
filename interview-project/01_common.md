## 数据同步过程中,如何处理区块链分叉问题？
```
处理方法
1. 等待 12 个区块确认（约 3 分钟）后再处理数据。
2. 同步 removed 字段，其中 removed = true 表示事件无效且已被废弃。
```

## evm 兼容链
```
1. Ethereum 用 ETH 支付 Gas，Polygon 用 MATIC，BSC 用 BNB。部署或交互时要使用对应代币。
2. Chainlink 等服务在不同链上地址不同，需要修改合约参数。
```

## Merkle tree
```
数据结构：
Merkle Tree 是哈希树/二叉树：
叶子节点存数据哈希，
父节点存子节点组合哈希，
根节点递归两两组合所有子节点哈希。
若任一子节点哈希变化，所有父节点哈希也会随之变化。

数据存储：
对于白名单，存储时只需保存根节点哈希，无需保存所有用户地址，从而显著减少存储开销。
数据验证：
验证的时候，您只需要提供叶哈希和 Merkle 证明（兄弟节点哈希数组）。
```

## gas优化
```
一.常规优化
int 存储槽优化: 把小的变量定义在一起，拼凑成 32字节，打包到同一slot，减少storage的存储
使用 memory, 存储  临时变量 ，以降低存储的gas 消耗。
使用 calldata 存储 外部函数 参数，以降低存储的gas 消耗。
使用 位移运算，替代 乘以2 和 除以2 的算法

二.代码架构的优化:
a. 链上只完成核心逻辑，复杂计算给到链下
比如: 贷款合约中，链下监控价格，触发链上清算，链上验证和执行

b. 贷款合约中，白名单机制使用 Merkle 而不是 mapping, 减少数据存储

c. iziswap中，定时计算 流动性提供者(LP)的手续费收入
每次swap ,流动性提供者(LP) 的手续费收入都会变化，如果每次计算 ，很消耗gas，怎么解决
1. 定时批量更新（Batching Updates）: 每10分钟更新一次
2. 当用户查看的时候更新

交易手续费 ： 平台抽取 1/6 , LP 获得 5/6 
0.05%（低风险池）
0.30%（中等波动池）
1.00%（高波动池）
```

##  安全和防御攻击
```
白名单机制 :防止 Sybil 攻击

多签机制 ：防止密钥丢失或被盗: 
如果管理员想要提取交易费，需要至少 5 名管理员中的 3 名批准。
    使用多重签名机制，防止密钥丢失或被盗（OpenZeppelin 的 AccessControl + 自定义签名验证）。

时间锁和紧急暂停机制:

重入攻击防护 :
1. 使用 ReentrancyGuard 合约防止重入攻击。
2. 先检查,再修改状态, 最后 交互/资产转账（CEI: Check-Effect-Interaction）
3. 拉取支付（Pull Over Push）模式: 不直接向用户转账，而是让用户主动提取。
   iziswap 中，流动性提供者（lp），赎回资产 ， 存入余额，让用户自己提取，而不是直接转账给账户

ReentrancyGuard 会消耗额外 gas，主要是因为对 _status 变量的 storage 读写。
规范代码习惯: 不能随意调整变量的大小和顺序

闪电贷攻击和防护：


```

## 什么是时间加权平均价格（TWAP）
```
TWAP = 时间加权平均价格，用于平滑价格波动。
核心作用：平滑价格波动、防止价格操纵、降低滑点。

Uniswap: 大额订单执行(把大的订单拆分成很多小的订单，分时间段执行)。

clearpool : 闪电贷的低价清算防护

```

##  UUPS 和 透明代理（Transparent Proxy）的相同和区别
```
设计目的 : 实现合约逻辑部分 可升级，同时保持状态不丢失。
模式相同 : 代理合约 + 实现合约
代理合约 : 保存状态变量，接收用户调用，通过 delegatecall 转发逻辑。
实现合约 : 具体的业务逻辑 。

不同点:
Transparent： 代理合约管理升级，每次升级都要 权限检查逻辑+转发，更费gas，更安全
UUPS： 实现合约管理升级，代理只负责转发，轻量且更节省 Gas。

代码层级: 
openzepplin 更兼容的是: UUPS
TransparentUpgradeableProxy -> ProxyAdmin (权限管理)
UUPSUpgradeable -> Initializable(初始化)
```

## 升级合约的 存储冲突
```
代理合约 : 保存状态变量，接收用户调用，通过 delegatecall 转发逻辑。
实现合约 : 具体的业务逻辑。由于使用的是 delegatecall ，所以，实现合约修改的是调用者（代理合约）的状态变量。

存储冲突: 
代理合约和逻辑合约, slot 初始化值（都是从0开始）和顺序相同，但是 数据都存储在代理合约，那么就会数据相互覆盖，存储冲突 。

解决方法: EIP-1967
给代理合约的 变量 分配一个很大的，固定的slot初始化值，保证不会与逻辑合约的业务变量 slot 冲突：
uups: keccak256("eip1967.proxy.implementation") - 1;

storage slot 是 uint256 范围（≈ 1.1579×10⁷⁷），而 EIP-1967 _IMPLEMENTATION_SLOT ≈ 0.246×10⁷⁷
```

