## go slice 的扩容
```
一. 定义和初始化: slice 是一个 封装类型，封装，指针（指向底层数组）,len(当前长度),cap (当前容量)
type slice struct {
    array unsafe.Pointer // 指向底层数组
    len   int            // 当前长度
    cap   int            // 当前容量
}
不指定长度的时候，初始没有分配桶，一次插入元素时才真正分配内存（懒加载）。
指定长度的时候，就会根据容量分配足够的桶

二. 扩容
触发条件
s = append(s, x)
当容量小于 1024 时: 每次扩容 翻倍（×2）
当容量 ≥ 1024 时: 每次扩容大约增长 1.25 倍（+25%）
```

## map 的扩容 
```
一. 定义和初始化
Go 的 map 是基于 哈希表（hash table）和 桶（bucket） 实现的 ,每个桶能存 最多 8 个键值对。
Go 的 map 
如果不指定容量，初始没有分配桶。第一次插入元素时才真正分配内存（懒加载）。
如果不指定容量，就会根据容量分配足够的桶 。

二. 扩容
1.等量扩容 : 数据分布不均匀，保持桶数量不变，只做 rehash
2.加倍扩容 : 装载因子过大(> 6.5), 即平均每个桶中元素太多,会触发扩容
```

## slice,map 创建的时候，应该指定长度吗
```
1. 如果长度很小（<100）或者大小不确定,可以不指定
2. 如果知道长度，而且长度比较长，建议制定，减少扩容的消耗
```

## channel 
```
无缓冲 channel :
写入的信息的时候: 一直阻塞直到有接收
有缓冲 channel :
写入的信息的时候 : 如果缓冲区慢，发生阻塞
```

## interface
```
一. 定义
interface 是一种 类型抽象

二.方法判断
interface 的底层是 两部分组成
类型信息（type）
数据指针（data）
s := i.(string) // 断言 i 是 string
v := i.(type)

三.分类和作用:
通用容器：空接口 interface{} 不包含任何方法 ： 可以存储 任意类型的值
多态与抽象： 带方法的接口：Person 实现了 Speaker 接口，隐式实现，不需要显式声明

```

## Promise
```
Promise 是 JS 异步操作的 封装，状态不可逆
.then() 和 .catch() 用于处理成功和失败
可以链式调用，实现 顺序异步逻辑
静态方法如 all, race 可处理 并行异步
```


## uniswap 的基本原理
```
1.Uniswap 是 去中心化交易所（DEX）
使用 AMM 自动做市商的方式 ，而不是订单薄

自动做市商 通过 流动性池 来实现资产的买卖  。
流动性池（Liquidity Pools）:AMM 基于流动性池来工作，流动性池是由两种或加密资产组成的池子（如 ETH 和 USDT）。这些资产由 流动性提供者（LPs） 存入池子中。
常数乘积公式（x * y = k）:AMM 使用数学公式来保持池子中的两种资产的平衡。例如，Uniswap 使用 x * y = k 的公式，其中:
k值在mint和burn(添加和减少流动性)的时候会成比例增大或缩小，在 swap的时候保持不变

```