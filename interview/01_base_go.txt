Q1: Goroutine
Goroutine：Goroutine is a lightweight thread，hundreds of thousands of goroutines can run in a single Go program concurrently
Channel： Channel is Go’s communication mechanism, used for safely passing data between goroutines.
Go’s concurrency philosophy: Do not communicate by sharing memory; instead, share memory by communicating.

Typical example (bin):
Worker Pool: the main goroutine generates tasks and sends them to a channel,
while worker goroutines get tasks from the channel and process them.

run(rʌn)
generates（ˈdʒenəreɪts）
sends （sendz）
process（prəˈses）

Q2: What’s the difference between arrays and slices in Go?
Arrays have a fixed length and are value types.
Slices have a dynamic length and are reference types, and  point to an array internally.

length(leŋθ)
Slices (ˈslaɪsɪz)
reference（ˈre/f/rəns）
internally (ɪnˈtɜːnəli)

Q3: What’s the purpose of the context package?
It manages the lifecycle of goroutines, supporting timeout, cancellation, and passing metadata.
cancellation (ˌkænsəˈleɪʃn)
lifecycle(laɪfˈsaɪkl)
metadata (ˈmetədeɪtə)

Q4: How does Go ensure stability in distributed systems?
By using timeout control (context),  and retry mechanisms.
ensure(ɪnˈʃʊr)
stability(stəˈbɪləti)

Q5: How does Go handle concurrency safety?
1. use Goroutine  and channels,channels are used for communication,
2. use the sync package, such as Mutex, RWMutex, and WaitGroup.